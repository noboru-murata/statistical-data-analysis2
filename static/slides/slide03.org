#+TITLE: 回帰分析 
#+SUBTITLE: モデルの推定
#+AUTHOR: 村田 昇
#+EMAIL: noboru.murata@eb.waseda.ac.jp
#+DATE: 2020.10.09
:reveal:
#+INCLUDE: "./reveal.js/org/mycourse.org"
#+STARTUP: hidestars content
# C-c C-x C-v でinlineを切り替え
# <m C-i でlatex block (math env用)
# C-c '
:end:

* COMMENT tangle用

#+begin_src R :exports none
  setwd("~/Desktop/lectures/u-tokyo/autumn/slide")
#+end_src
#+begin_src R :eval no :exports none :tangle yes
  ### 第03回 練習問題解答例
#+end_src


* 疑似乱数
** 疑似乱数とは
   - コンピューターで生成された数列のこと
   - 完全にランダムに数字を発生されることは不可能
   - Rの既定値は "Mersenne-Twister法" (~?Random~ 参照)
   - 数値シミュレーションにおいて再現性が要請される場合には，
     乱数の "シード値" を指定して再現性を担保 (関数 ~set.seed()~)

** 基本的な乱数
   - *ランダムサンプリング*: 与えられた集合の要素を無作為抽出することで発生する乱数
   - *二項乱数*: 「確率 $p$ で表がでるコインを $n$ 回投げた際の表が出る回数」に対応する乱数
   - *一様乱数*: 決まった区間 $(a, b)$ からランダムに発生する乱数
   - *正規乱数*: 平均 $\mu$, 分散 $\sigma^2$ の正規分布に従う乱数

** 乱数を生成する関数
   - 関数 ~sample()~: ランダムサンプリング
   - 関数 ~rbinom()~: 二項乱数
   - 関数 ~runif()~: 一様乱数
   - 関数 ~rnorm()~: 正規乱数
** 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - ヘルプを用いて以下の関数を調べよ
     - 関数 ~sample()~
     - 関数 ~rbinom()~
     - 関数 ~runif()~
     - 関数 ~rnorm()~
     - 関数 ~set.seed()~
   - 以下の試行を実装してみよ
     - サイコロを10回振る
     - 4枚のコインを投げたときの表の枚数
     #+begin_src R :eval no :exports none :tangle yes
       ### 練習6 (第2回の続き)
       ### 擬似乱数

       ## 関数sampleの使い方
       (x <- 1:10)   # サンプリング対象の集合を定義
       set.seed(123) # 乱数のシード値(任意に決めてよい)を指定
       sample(x, 5)               # xから5つの要素を重複なしでランダムに抽出
       sample(x, 5, replace=TRUE) # xから5つの要素を重複ありでランダムに抽出
       sample(x, length(x))       # xの要素のランダムな並べ替え
       sample(1:6, 10, replace=TRUE)           # サイコロを10回振る実験の再現
       sample(1:6, 10, prob=6:1, replace=TRUE) # 出る目の確率に偏りがある場合

       ## 関数rbinomの使い方
       rbinom(10, size=4, prob=0.5) # 表(1)の出る確率が0.5にコインを4枚投げる試行を10回
       rbinom(20, size=4, prob=0.2) # 個数を20, 確率を0.2に変更

       ## 関数runifの使い方
       runif(5, min=-1, max=2) # 区間(-1,2)上の一様乱数を5個発生
       runif(5)                # 指定しない場合は区間(0,1)が既定値

       ## 関数rnormの使い方
       rnorm(10, mean=5, sd=3) # 平均5，分散3^2の正規乱数を10個発生
       rnorm(10)               # 指定しない場合は mu=0, sd=1 が既定値

       ## 関数set.seedについて
       set.seed(1) # 乱数の初期値をseed=1で指定
       runif(5) 
       set.seed(2) # 乱数の初期値をseed=2で指定
       runif(5)    # seed=1の場合と異なる結果
       set.seed(1) # 乱数の初期値をseed=1で指定
       runif(5)    # 初めのseed=1の場合と同じ結果
     #+end_src


* モンテカルロ法
** モンテカルロ法とは
   - 乱数を使った統計実験
   - 計算機上でランダムネスを実現 (擬似乱数)
   - ランダムネスから導かれる種々の数学的結果を観察

** 例: 中心極限定理
   - 定理
     #+begin_quote
     $X_1,X_2,\dotsc$ を独立同分布な確率変数列とし，
     その平均を $\mu$ ，標準偏差を $\sigma$ とする．
     このとき，すべての実数 $a< b$ に対して
     #+begin_src latex
       \begin{equation}
         P\Bigl(a\leq\frac{\sqrt{n}(\bar{X}_n-\mu)}{\sigma}\leq b \Bigr)
         \to\frac{1}{\sqrt{2\pi}}\int_a^be^{-\frac{x^2}{2}}dx\quad
         (n\to\infty)
       \end{equation}
     #+end_src
     が成り立つ．
     #+end_quote
   - 直感的には "多数の独立な確率変数の和はほぼ正規分布に従う" ことを主張している
   #+reveal: split
     #+begin_src R :eval no :exports none :tangle yes
       ### 中心極限定理
     #+end_src
     #+begin_src R :eval no :tangle yes
       ## 確率変数の分布の設定 (例: 区間[-1,1]の一様乱数)
       myrand <- function(n) { # n個の乱数を生成
           return(runif(n,min=-1,max=1))
       }
       ## 標本平均の計算
       mymean <- function(n) { # n個のデータで計算
           return(mean(myrand(n)))
       }
     #+end_src
     #+begin_src R :eval no :tangle yes
       ## Monte-Carlo実験
       set.seed(123) # 実験を再現したい場合はシードを指定する
       mu <- 0; sigma <- sqrt(1/3) # 理論平均と標準偏差
       mc <- 5000 # 実験の繰り返し回数
       for(n in c(1,2,4,8,16)){ # nを変えて実験
           xbars <- replicate(mc, mymean(n)) # mc回実験し標本平均を記録
           hist(xbars, breaks=25, freq=FALSE, # 分布を表示
                col="orchid", border="slateblue",
                xlab=expression(bar(X)), main=paste0("n=",n))
           thdist <- function(x){dnorm(x,mean=mu,sd=sigma/sqrt(n))}
           curve(thdist, add=TRUE, col="orange", lwd=2) # 理論曲線を重ねる
       }
     #+end_src
   
** 例: コイン投げの賭け
   - AとBの二人で交互にコインを投げる．
     最初に表が出た方を勝ちとするとき，
     AとBそれぞれの勝率はいくつとなるか？
   - コイン投げは関数 ~sample()~, ~rbinom()~ などを用いて模擬できる
     #+begin_src R :eval no
       sample(0:1,1) # 0と1が入った壺からから1つ選ぶ
       rbinom(1,size=1,prob=0.5) # 表裏が等確率で出る1枚のコインを1回投げる
     #+end_src

   #+reveal: split
     #+begin_src R :eval no :exports none :tangle yes
       ### コイン投げの賭け
     #+end_src
     #+begin_src R :eval no :tangle yes
       ## コイン投げの試行 (いろいろな書き方があるので以下は一例)
       mytrial <- function(){
           while(TRUE){ # 永久に回るループ
               if(rbinom(1,size=1,prob=0.5)==1){return("A")} # Aが表で終了
               if(rbinom(1,size=1,prob=0.5)==1){return("B")} # Bが表で終了
               ## どちらも裏ならもう一度ループ
           }
       }
     #+end_src
     #+begin_src R :eval no :tangle yes
       ## Monte-Carlo実験
       set.seed(8888) # 実験を再現したい場合はシードを指定する
       mc <- 10000 # 実験回数を設定 
       mydata <- replicate(mc,mytrial()) 
       ## 簡単な集計
       table(mydata)    # 頻度
       table(mydata)/mc # 確率(推定値)
     #+end_src

** 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 以下の簡単な双六ゲームの実験を行ってみよう
     - ゴールまでのます目は100
     - さいころを振り出た目の数だけ進む
     - ゴールに辿り着くまで繰り返す
     - さいころを振る回数の分布は?
     #+begin_src R :eval no :exports none :tangle yes
       ### 練習7 (第2回の続き)
       ### 双六ゲーム

       ## 双六の試行
       mytrial <- function(){
           step <- 0 # 最初の位置
           num <- 0  # さいころを振る回数
           while(TRUE){ # 永久に回るループ
               step <- step + sample(1:6,1) # さいころを振る
               num <- num + 1 # 回数を記録
               if(step >= 100) { # ゴールしたか?
                   return(num) # 回数を出力して関数を終了
               }
           }
       }

       ## 試行を行ってみる
       for(i in 1:10) print(mytrial())
       
       ## Monte-Carlo実験
       set.seed(12345)
       mc <- 10000 # 実験回数を設定 
       mydata <- replicate(mc,mytrial()) 
       hist(mydata) # ヒストグラムを出力
       summary(mydata) # 簡単な集計
     #+end_src
     

* 補足
  - より詳細な確率シミュレーションについては以下を参照して下さい
    - 講義ノート
      - R言語の基礎 第5章 (pp71-82)
        - Buffon の針
        - Monty Hall 問題
        - 秘書問題 (最適停止問題)
	などの実装例がある
    - 統計データ解析I スライド 
      - 講義5 確率シミュレーション



* 講義の予定
  - *第1日: 回帰モデルの考え方と推定*
  - 第2日: モデルの評価
  - 第3日: モデルによる予測と発展的なモデル


* 回帰分析の考え方
** 回帰分析 (regression analysis)
   - ある変量を別の変量で説明する関係式を構成
   - 関係式: *回帰式* (regression equation)
     - 説明される側: *目的変数*, 被説明変数, 従属変数, 応答変数
     - 説明する側: *説明変数*, 独立変数, 共変量
   - 説明変数の数による分類:
     - 一つの場合: *単回帰* (simple regression)
     - 複数の場合: *重回帰* (multiple regression)
     
** 一般の回帰の枠組
   - 説明変数: $x_1,\dotsc,x_p$ (p次元)
   - 目的変数: $y$ (1次元)
   - 観測データ: n個の $(y,x_1,\dotsc,x_p)$ の組
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \{(y_i,x_{i1},\dotsc,x_{ip})\}_{i=1}^n
       \end{equation}
     #+end_src
     #+end_quote
   - $y$ を $x_1,\dotsc,x_p$ で説明するための関係式を構成:
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         y=f(x_1,\dotsc,x_p)
       \end{equation}
     #+end_src
     #+end_quote
   #     一般には p変数関数 $f$ を使う

** 線形回帰 (linear regression)
   - 任意の $f$ では一般的すぎて分析に不向き
   - $f$ として1次関数を考える\\
     ある定数 $\beta_0,\beta_1,\dots,\beta_p$ を用いた以下の式:
     #+begin_quote
     #+begin_src latex
       \begin{equation}
	 f(x_1,\dots,x_p)=\beta_0+\beta_1x_1+\cdots+\beta_px_p
       \end{equation}
     #+end_src
     #+end_quote
     - 1次関数の場合: *線形回帰* (linear regression)
     - 一般の場合: 非線形回帰 (nonlinear regression)
   - 非線形関係は新たな説明変数の導入で対応可能
     - 適切な多項式 $x_j^2, x_jx_k, x_jx_kx_l,\dotsc$
     - その他の非線形変換 $\log x_j, x_j^\alpha,\dotsc$ 

** 回帰係数
   - 線形回帰式:
     #+begin_quote
     #+begin_src latex
       \begin{equation}
	 y=\beta_0+\beta_1x_1+\cdots+\beta_px_p
       \end{equation}
     #+end_src
     #+end_quote
   - $\beta_0,\beta_1,\dots,\beta_p$: *回帰係数* (regression coefficients)
   - $\beta_0$: *定数項 / 切片* (constant term / intersection)
   - 線形回帰分析: 未知の回帰係数をデータから決定

** 回帰の確率モデル
   - 回帰式の不確定性
     - データは一般に観測誤差などランダムな変動を含む
     - 回帰式がそのまま成立することは期待できない
   - 確率モデル: データのばらつきを表す項 $\epsilon_i$ を追加
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         y_i=\beta_0+\beta_1 x_{i1}+\cdots+\beta_px_{ip}+\epsilon_i\quad (i=1,\dots,n)
       \end{equation}
     #+end_src
     #+end_quote
     - $\epsilon_1,\dots,\epsilon_n$: *誤差項 / 撹乱項* (error / disturbance term)
       - 誤差項は独立な確率変数と仮定
       - 多くの場合，平均0，分散 $\sigma^2$ の正規分布を仮定
     - *推定* (estimation):
       観測データから
       $(\beta_0,\beta_1,\dots,\beta_p)$ 
       を決定


* 回帰係数の推定
** 残差
   - *残差* (residual):
     回帰式で説明できない変動
   - 回帰係数 $\boldsymbol{\beta}=(\beta_0,\beta_1,\dotsc,\beta_p)^\mathsf{T}$ 
     を持つ回帰式の残差:
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         e_i(\boldsymbol{\beta})=
         y_i-(\beta_0+\beta_1 x_{i1}+\dotsb+\beta_px_{ip})
         \quad (i=1,\dotsc,n)
       \end{equation}
     #+end_src
     #+end_quote
   - 残差 $e_i(\boldsymbol{\beta})$ の絶対値が小さいほど当てはまりがよい

** 最小二乗法 (least squares)
   - *残差平方和* (residual sum of squares):
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         S(\boldsymbol{\beta}):=
         \sum_{i=1}^ne_i(\boldsymbol{\beta})^2
       \end{equation}
     #+end_src
     #+end_quote
   - *最小二乗推定量* (least squares estimator): 
     #+begin_quote
     残差平方和
     $S(\boldsymbol{\beta})$
     を最小にする
     $\boldsymbol{\beta}$
     #+begin_src latex
       \begin{equation}
         \boldsymbol{\hat{\beta}}=(\hat{\beta}_0,\hat{\beta}_1,\dotsc,\hat{\beta}_p)^\mathsf{T}:=
         \arg\min_{\boldsymbol{\beta}}S(\boldsymbol{\beta})
       \end{equation}
     #+end_src
     #+end_quote
     
** 行列の定義
   - デザイン行列 (design matrix):
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         X=
         \begin{pmatrix}
           1 & x_{11} & x_{12} & \cdots & x_{1p} \\
           1 & x_{21} & x_{22} & \cdots & x_{2p} \\
           \vdots & \vdots & \vdots & & \vdots \\
           1 & x_{n1} & x_{n2} & \cdots & x_{np}
         \end{pmatrix}
       \end{equation}
     #+end_src
     #+end_quote

** ベクトルの定義
   - 目的変数，誤差，回帰係数のベクトル:
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \boldsymbol{y}=
         \begin{pmatrix}
           y_1 \\
           y_2 \\
           \vdots \\
           y_n
         \end{pmatrix},\quad
         \boldsymbol{\epsilon}=
         \begin{pmatrix}
           \epsilon_1 \\
           \epsilon_2 \\
           \vdots \\
           \epsilon_n
         \end{pmatrix},\quad
         \boldsymbol{\beta}=
         \begin{pmatrix}
           \beta_0 \\
           \beta_1 \\
           \vdots \\
           \beta_p
         \end{pmatrix}
       \end{equation}
     #+end_src
     #+end_quote
     
** 行列・ベクトルによる表現
   - 確率モデル:
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \boldsymbol{y}
         =X\boldsymbol{\beta}+\boldsymbol{\epsilon}
       \end{equation}
     #+end_src
     #+end_quote
   - 残差平方和:
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         S(\boldsymbol{\beta})
         =(\boldsymbol{y}-X\boldsymbol{\beta})^\mathsf{T}
         (\boldsymbol{y}-X\boldsymbol{\beta})
       \end{equation}
     #+end_src
     #+end_quote
     
** 解の条件
   - 解 $\boldsymbol{\beta}$ では残差平方和の勾配は零ベクトル
     # \footnote{例えば杉浦光夫著「解析入門I」(東京大学出版会)の第II章定理8.1参照}:
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \nabla S(\boldsymbol{\beta}):=
         \Bigl(
	 \frac{\partial S}{\partial\beta_0}(\boldsymbol{\beta}),
	 \frac{\partial S}{\partial\beta_1}(\boldsymbol{\beta}),\dotsc,
	 \frac{\partial S}{\partial\beta_p}(\boldsymbol{\beta})
         \Bigr)^\mathsf{T}=\boldsymbol{0}
       \end{equation}
     #+end_src
     #+end_quote
   - 成分 ($j=0,1,\dotsc,p$) ごとの条件式
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \frac{\partial S}{\partial\beta_j}(\boldsymbol{\beta})
         =
         -2\sum_{i=1}^n\Bigl(y_i-\sum_{k=0}^p\beta_kx_{ik}\Bigr)x_{ij}
         =0
       \end{equation}
     #+end_src
     但し $x_{i0}=1\; (i=1,\dotsc,n)$
     #+end_quote

** 正規方程式 (normal equation)
   - 条件を整理
     ($x_{ij}$ は行列 $X$ の $(i,j)$ 成分)
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \sum_{i=1}^nx_{ij}\Bigl(\sum_{k=0}^px_{ik}\beta_k\Bigr)
         =
         \sum_{i=1}^nx_{ij}y_i\quad(j=0,1,\dotsc,p)
       \end{equation}
     #+end_src
     #+end_quote
   - *正規方程式* (normal equation):
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         X^\mathsf{T}X\boldsymbol{\beta}
         =X^\mathsf{T}\boldsymbol{y}
       \end{equation}
     #+end_src
     #+end_quote
   - *Gram行列* (Gram matrix):
     $X^\mathsf{T}X$ 

** 正規方程式の解
   - 正規方程式の基本的な性質
     - 正規方程式は必ず解をもつ (一意に決まらない場合もある)
     - 正規方程式の解は最小二乗推定量であるための必要条件
   - Gram 行列 $X^\mathsf{T}X$ が正則ならば解が一意に決定
   - 正規方程式の解
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \boldsymbol{\hat{\beta}}
         =
         (X^\mathsf{T}X)^{-1}X^\mathsf{T}\boldsymbol{y}  
       \end{equation}
     #+end_src
     #+end_quote
     
** R: 関数 ~lm()~ による推定
   - ベクトルを用いる基本的な使い方:
     #+begin_src R :eval no
       lm(formula= y ~ x1 + ... + xp)
       ## formula: 目的変数 ~ 説明変数 (複数ある場合は + で並べる)
       ## y: 目的変数のベクトル
       ## x1,...,xp: 各説明変数のベクトル
     #+end_src
   - データフレームを用いる方法: *(こちらを推奨)*
     #+begin_src R :eval no
       lm(formula= yの変数名 ~ x1の変数名 + ... + xpの変数名,
          data = データフレーム)
       ## formula: 目的変数名 ~ 説明変数名
       ## data: 目的変数，説明変数を含むデータフレーム
     #+end_src
** データセットの準備
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 回帰分析では以下のデータセットを使用します
     - ~tokyo_weather_reg.csv~
       #+begin_quote
       気象庁より取得した東京の気象データを回帰分析用に整理したもの
       #+end_quote
       https://www.data.jma.go.jp/gmd/risk/obsdl/index.php
     - ~Advertising.csv~
       #+begin_quote
       広告費(TV,radio,newspapers)と売上の関係を調べたもの
       
       "Datasets in this presentation are taken from "An
       Introduction to Statistical Learning, with applications in R"
       (Springer, 2013) with permission from the authors: G. James,
       D. Witten, T. Hastie and R. Tibshirani "
       #+end_quote
       http://faculty.marshall.usc.edu/gareth-james/ISL/Advertising.csv
       
** COMMENT 演習: 回帰式の推定
   :PROPERTIES:
   :reveal_background: #EEEEFF
   :END:
   - [[./code/04-lm.r][04-lm.r]] を確認してみよう
   
** 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 前掲のデータセットを用いて回帰式を構成しなさい
     - 東京都の8月の気候データ
       #+begin_quote
       temp ~ solar + press
       #+end_quote
     - 広告費と売上データ
       #+begin_quote
       sales ~ TV
       
       sales ~ radio

       sales ~ TV + radio
       #+end_quote
     #+begin_src R :eval no :exports none :tangle yes
       ### 練習1
       ### 回帰係数の推定

       ### 東京都の気候データによる回帰分析
       ## モデル: 8月の"気温"を目的変数，"日射量・気圧"を説明変数とする
       TW.data <- read.csv("data/tokyo_weather_reg.csv")
       TW.model <- temp ~ solar + press # モデル式の定義 
       ## class(model) # モデルは formula class
       (TW.est <- lm(TW.model, # 回帰係数の推定
                  data=subset(TW.data, # 8月のデータの抽出
                              subset= months(as.Date(date),
                                             abbreviate=TRUE)==" 8"))) 
       TW.df <- model.frame(TW.est) # 推定に用いたデータフレームの抽出 (後述)
       plot(TW.df, col="blue")   # 散布図

       ## 散布図と回帰式の定める平面の描画(3次元プロット)
       require(scatterplot3d) # パッケージの読み込み
       s3d <- scatterplot3d( 
           TW.df[c("solar","press","temp")], # x,y,z の順
           type="p", # plotの種類: "p"点，"l"線，"h"足付き
           pch=16,# 点の種類 (?points 参照)
           angle=30, # xy平面の見る方向 (適宜調整)
           highlight.3d=TRUE # 高さ(z)ごとに色を変える
       )
       s3d$plane3d(TW.est, col="blue", # 回帰式の定める平面の追加
                   draw_polygon=TRUE, # 平面の塗り潰しの設定
                   polygon_args=list(col=rgb(0,0,1,0.1))) 
       
       ### 広告費と売上データによる回帰分析
       Adv.data <- read.csv("data/Advertising.csv",
                            row.names=1) # 1列目を行名として読み込む
       ## 以下のように download しないで URL を指定してもよい
       ## read.csv("http://faculty.marshall.usc.edu/gareth-james/ISL/Advertising.csv")
       plot(Adv.data, col="orange")
       ## TVの宣伝費で売上を説明
       (Adv.est1 <- lm(sales ~ TV, data=Adv.data))
       plot(sales ~ TV, data=Adv.data, col="orange")
       abline(Adv.est1, col="brown", lwd=2)
       ## radioの宣伝費で売上を説明
       (Adv.est2 <- lm(sales ~ radio, data=Adv.data))
       plot(sales ~ radio, data=Adv.data, col="orange")
       abline(Adv.est2, col="brown", lwd=2)
       ## 両者の宣伝費で売上を説明
       (Adv.est <- lm(sales ~ TV + radio, data=Adv.data))
       s3d <- scatterplot3d( 
           model.frame(Adv.est)[c("TV","radio","sales")], # x,y,z の順
           type="p", # plotの種類: "p"点，"l"線，"h"足付き
           pch=16,# 点の種類 (?points 参照)
           angle=45, # xy平面の見る方向 (適宜調整)
           highlight.3d=TRUE # 高さ(z)ごとに色を変える
       )
       s3d$plane3d(Adv.est, col="brown", # 回帰式の定める平面の追加
                   draw_polygon=TRUE, # 平面の塗り潰しの設定
                   polygon_args=list(col=rgb(1,0,0,0.1))) 
     #+end_src


* 最小二乗推定量の性質
** 解と観測データの関係
   - 解析の上での良い条件:
     - 最小二乗推定量がただ一つだけ存在する (以下同値条件)
       - $X^\mathsf{T}X$ が正則
       - $X^\mathsf{T}X$ の階数が $p{+}1$
       - $X$ の階数が $p{+}1$
       - $X$ の列ベクトルが1次独立
   - 解析の上での良くない条件:
     - 説明変数が1次従属: *多重共線性* (multicollinearity)
     - 説明変数は多重共線性が強くならないように選択するべき 
       - $X$ の列(説明変数)の独立性を担保する
       - 説明変数が互いに異なる情報をもつように選ぶ
       - 似た性質をもつ説明変数の重複は避ける

** 推定の幾何学的解釈
   - *あてはめ値 / 予測値* (fitted values / predicted values):
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \boldsymbol{\hat{y}}
         =
         X\boldsymbol{\hat{\beta}}
         =
         \hat{\beta}_{0} X_\text{第0列} + 
         \dots + \hat{\beta}_{p} X_\text{第p列}
       \end{equation}
     #+end_src
     #+end_quote
   - 最小二乗推定量 $\boldsymbol{\hat{y}}$ の幾何学的性質:
     - $L[X]$: $X$ の列ベクトルが張る $\mathbb{R}^n$ の部分線形空間
     - $X$ の階数が $p{+}1$ ならば $L[X]$ の次元は $p{+}1$ (解の一意性)
     - $\boldsymbol{\hat{y}}$ は $\boldsymbol{y}$ の $L[X]$ への直交射影
     - *残差* (residuals)
       $\boldsymbol{\hat{\epsilon}}:=\boldsymbol{y}-\boldsymbol{\hat{y}}$
       はあてはめ値
       $\boldsymbol{\hat{y}}$ に直交
       #+begin_quote
       #+begin_src latex
	 \begin{equation}
           \boldsymbol{\hat{\epsilon}}\cdot\boldsymbol{\hat{y}}=0
         \end{equation}
       #+end_src
       #+end_quote
   #+reveal: split
   - 幾何学的な考察からも一意に決まる
   #+CAPTION: $n=3$ , $p+1=2$ の場合の最小二乗法による推定
   #+NAME:   fig:projection
   #+ATTR_HTML: :width 80% :height 80%
   [[file:./figs/projection.png]]

** 線形回帰式と標本平均
   - $\boldsymbol{x}_i=(x_{i1},\dotsc,x_{ip})^\mathsf{T}$:
     説明変数の $i$ 番目の観測データ
   - 説明変数および目的変数の標本平均:
     #+begin_quote
     #+begin_src latex
     \begin{align}
       \boldsymbol{\bar{x}}
       &=\frac{1}{n}\sum_{i=1}^n\boldsymbol{x}_i,
       &\bar{y}
       % \overline{\boldsymbol{x}^2}&=\frac{1}{n}\sum_{i=1}^n\boldsymbol{x}_i\boldsymbol{x}_i^\mathsf{T},&
       &=\frac{1}{n}\sum_{i=1}^ny_i,&
       % \overline{\boldsymbol{x}y}&=\frac{1}{n}\sum_{i=1}^n\boldsymbol{x}_iy_i
     \end{align}
     #+end_src
     #+end_quote
   - $\boldsymbol{\hat{\beta}}$ が最小二乗推定量のとき以下が成立:
     #+begin_quote
     #+begin_src latex
     \begin{equation}
       \bar{y}
       =
       (1,\boldsymbol{\bar{x}}^\mathsf{T})\boldsymbol{\hat{\beta}}
     \end{equation}
     #+end_src
     #+end_quote
   #+reveal: split     
   - 以下の関係から簡単に示すことができる
     #+begin_quote
     #+begin_src latex
       \begin{equation}
         \boldsymbol{1}\cdot(\boldsymbol{y}-\boldsymbol{\hat{y}})
         =\boldsymbol{1}\cdot\boldsymbol{\hat{\epsilon}}
         =0
       \end{equation}
     #+end_src
     #+end_quote
   # #+BEGIN_QUOTE
   # 幾何学的には $y=(1,\boldsymbol{x}^\mathsf{T})\boldsymbol{\hat{\beta}}$ 
   # によって定まる超平面は常に点 $(\boldsymbol{\bar{x}}^\mathsf{T},\bar{y})$ 
   # (標本平均)を通る
   # #+END_QUOTE

** R: 推定結果からの情報の取得
   - 関数 ~lm()~ の出力には様々な情報が含まれる
   #+begin_src R :eval no
     ## lmの出力を引数とする関数の例
     coef(lmの出力)         # 推定された回帰係数
     fitted(lmの出力)       # あてはめ値
     resid(lmの出力)        # 残差
     model.frame(lmの出力)  # modelに必要な変数の抽出 (データフレーム)
     model.matrix(lmの出力) # デザイン行列
   #+end_src
** R: 行列とベクトルの計算
   - $X^\mathsf{T}Y$ および $X^\mathsf{T}X$ の計算
     #+begin_src R :eval no
       crossprod(X, Y) # cross product の略
       ## X: 行列 (またはベクトル)
       ## Y: 行列 (またはベクトル)
       crossprod(X) # 同じものを掛ける場合は引数は1つで良い
     #+end_src
   - 行列 $A,B$ の積 $AB$
     #+begin_src R :eval no
       A %*% B # 行列の大きさは適切である必要がある
     #+end_src
   - 正方行列 $A$ の逆行列 $A^{-1}$
     #+begin_src R :eval no
       solve(A) # 他にもいくつか関数はある
     #+end_src

** COMMENT 演習: 最小二乗推定量の性質
   :PROPERTIES:
   :reveal_background: #EEEEFF
   :END:
   - [[./code/04-lse.r][04-lse.r]] を確認してみよう
** 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 前問の推定結果を用いて
     最小二乗推定量の性質を確認しなさい
     - 推定された係数が正規方程式の解
       #+begin_quote
       #+begin_src latex
	 \begin{equation}
           \boldsymbol{\hat{\beta}}
           =
           (X^\mathsf{T}X)^{-1}X^\mathsf{T}\boldsymbol{y}  
         \end{equation}
       #+end_src
       #+end_quote
       となること
     - あてはめ値と残差が直交すること
     - 回帰式が標本平均を通ること
     #+begin_src R :eval no :exports none :tangle yes
       ### 練習2
       ### 最小二乗推定量の性質

       ### 東京都の気候データ
       ## 回帰係数と正規方程式の解の一致
       (beta <- coef(TW.est))        # 推定された回帰係数
       X <- model.matrix(TW.est)     # デザイン行列
       Y <- model.frame(TW.est)[[1]] # 目的変数 (データフレームの1列目に入っている)
       solve(crossprod(X)) %*% crossprod(X, Y) # 正規方程式の解
       ## あてはめ値と残差の直交性
       yhat <- fitted(TW.est) # あてはめ値
       ehat <- resid(TW.est)  # 残差
       yhat %*% ehat          # 直交すれば内積はO(に近い値)となる
       ## 回帰式が標本平均を通ること
       colMeans(X) %*% beta # 説明変数の標本平均のあてはめ値
       mean(Y)              # 目的変数の標本平均 
       
       ### 広告費と売上データ
       (beta <- coef(Adv.est))        # 推定された回帰係数
       X <- model.matrix(Adv.est)     # デザイン行列
       Y <- model.frame(Adv.est)[[1]] # 目的変数
       solve(crossprod(X)) %*% crossprod(X, Y) # 正規方程式の解
       ## あてはめ値と残差の直交性
       yhat <- fitted(Adv.est) # あてはめ値
       ehat <- resid(Adv.est)  # 残差
       yhat %*% ehat           # 直交すれば内積はO
       ## 回帰式が標本平均を通ること
       colMeans(X) %*% beta # 説明変数の標本平均のあてはめ値
       mean(Y)              # 目的変数の標本平均 
     #+end_src
   
* 残差の分解
** 最小二乗推定量の残差
   - 観測値と推定値 $\boldsymbol{\hat{\beta}}$ による予測値の差:
     #+begin_quote
     #+begin_src latex
     \begin{equation}
       \hat{\epsilon}_i=
       y_i-(\hat{\beta}_0+\hat{\beta}_1 x_{i1}+\dotsb+\hat{\beta}_px_{ip})
       \quad (i=1,\dotsc,n)
     \end{equation}
     #+end_src
     #+end_quote
     - 誤差項 $\epsilon_1,\dotsc,\epsilon_n$ の推定値
     - 全てができるだけ小さいほど良い
     - 予測値とは独立に偏りがないほど良い
   - 残差ベクトル:
     #+begin_quote
     #+begin_src latex
     \begin{equation}
       \boldsymbol{\hat{\epsilon}}
       =\boldsymbol{y}-\boldsymbol{\hat{y}}
       =(\hat{\epsilon}_1,\hat{\epsilon}_2,\dotsc,\hat{\epsilon}_n)^{\mathsf{T}}
     \end{equation}
     #+end_src
     #+end_quote
   # - 標本平均のベクトル
   #   #+begin_src latex
   #   \begin{equation}
   #     \bar{\boldsymbol{y}}=\bar{y}\boldsymbol{1}=(\bar{y},\bar{y},\dotsc,\bar{y})^{\mathsf{T}}
   #   \end{equation}
   #   #+end_src

** 平方和の分解
   - 標本平均のベクトル:
     $\bar{\boldsymbol{y}}=\bar{y}\boldsymbol{1}=(\bar{y},\bar{y},\dotsc,\bar{y})^{\mathsf{T}}$
   - いろいろなばらつき
     - $S_y=(\boldsymbol{y}-\bar{\boldsymbol{y}})^{\mathsf{T}}
       (\boldsymbol{y}-\bar{\boldsymbol{y}})$:
       目的変数のばらつき
     - $S_{\phantom{y}}=(\boldsymbol{y}-\boldsymbol{\hat{y}})^{\mathsf{T}}
       (\boldsymbol{y}-\boldsymbol{\hat{y}})$:
       残差のばらつき
       ($\boldsymbol{\hat{\epsilon}}^{\mathsf{T}}\boldsymbol{\hat{\epsilon}}$)
     - $S_r=(\boldsymbol{\hat{y}}-\bar{\boldsymbol{y}})^{\mathsf{T}}
       (\boldsymbol{\hat{y}}-\bar{\boldsymbol{y}})$:
       あてはめ値(回帰)のばらつき
   - 3つのばらつき(平方和)の関係
     #+begin_quote
     #+begin_src latex
     \begin{equation}
       (\boldsymbol{y}-\bar{\boldsymbol{y}})^{\mathsf{T}}
       (\boldsymbol{y}-\bar{\boldsymbol{y}})
       =
       (\boldsymbol{y}-\boldsymbol{\hat{y}})^{\mathsf{T}}
       (\boldsymbol{y}-\boldsymbol{\hat{y}})+ 
       (\boldsymbol{\hat{y}}-\bar{\boldsymbol{y}})^{\mathsf{T}}
       (\boldsymbol{\hat{y}}-\bar{\boldsymbol{y}})
     \end{equation}
     \begin{equation}
       S_y=S+S_r
     \end{equation}
     #+end_src
     #+end_quote
   #+reveal: split
   - 証明には以下の関係を使う
     #+begin_quote
     #+begin_src latex
     \begin{align}
       &\boldsymbol{y}-\bar{\boldsymbol{y}}
	 =\boldsymbol{y}-\boldsymbol{\hat{y}}+\boldsymbol{\hat{y}}-\bar{\boldsymbol{y}}\\
       &\boldsymbol{\hat{y}}\cdot(\boldsymbol{y}-\boldsymbol{\hat{y}})
	 =\boldsymbol{\hat{y}}\cdot\boldsymbol{\hat{\epsilon}}
	 =0\\
       &\boldsymbol{1}\cdot(\boldsymbol{y}-\boldsymbol{\hat{y}})
	 =\boldsymbol{1}\cdot\boldsymbol{\hat{\epsilon}}
	 =0
     \end{align}
     #+end_src
     #+end_quote

** COMMENT 演習: 残差の性質
   :PROPERTIES:
   :reveal_background: #EEEEFF
   :END:
   - [[./code/04-resid.r][04-resid.r]] を確認してみよう

** 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 前問の推定結果を用いて
     残差の性質を確認しなさい
     - 以下の分解
       #+begin_quote
       #+begin_src latex
	 \begin{equation}
           (\boldsymbol{y}-\bar{\boldsymbol{y}})^{\mathsf{T}}
           (\boldsymbol{y}-\bar{\boldsymbol{y}})
           =
           (\boldsymbol{y}-\boldsymbol{\hat{y}})^{\mathsf{T}}
           (\boldsymbol{y}-\boldsymbol{\hat{y}})+ 
           (\boldsymbol{\hat{y}}-\bar{\boldsymbol{y}})^{\mathsf{T}}
           (\boldsymbol{\hat{y}}-\bar{\boldsymbol{y}})
         \end{equation}
         \begin{equation}
           S_y=S+S_r
         \end{equation}
       #+end_src
       #+end_quote
       が成り立つこと
     #+begin_src R :eval no :exports none :tangle yes
       ### 練習3
       ### 残差の分解

       ### 東京都の気候データ
       TW.model
       TW.est <- lm(TW.model,
                    data=subset(TW.data, # 8月のデータの抽出
                                subset= months(as.Date(date),
                                               abbreviate=TRUE)==" 8"),
                    y=TRUE) # 目的変数をYとして返すように指定
       Y <- with(TW.est,y)                     # 目的変数の取得
       (Sy <- sum((Y-mean(Y))^2))              # 目的変数のばらつき
       (S <- sum(resid(TW.est)^2))             # 残差のばらつき
       (Sr <- sum((fitted(TW.est)-mean(Y))^2)) # 回帰のばらつき
       S+Sr # Sy と同じになっている
       
       ### 広告費と売上データ
       summary(Adv.est)
       Y <- model.frame(Adv.est)[[1]]           # 目的変数の取得
       (Sy <- sum((Y-mean(Y))^2))               # 目的変数のばらつき
       (S <- sum(resid(Adv.est)^2))             # 残差のばらつき
       (Sr <- sum((fitted(Adv.est)-mean(Y))^2)) # 回帰のばらつき
       S+Sr # Sy と同じになっている
     #+end_src
   

* 決定係数
** 回帰式の寄与
   - ばらつきの分解:
     #+begin_quote
     #+begin_src latex
     \begin{equation}
       S_y\;\text{(目的変数)} =S\;\text{(残差)} +S_r\;\text{(あてはめ値)}
     \end{equation}
     #+end_src
     #+end_quote
   - 回帰式で説明できるばらつきの比率:
     #+begin_quote
     #+begin_src latex
     \begin{equation}
       \text{(回帰式の寄与率)}
       = \frac{S_{r}}{S_{y}}
       = 1-\frac{S}{S_{y}}
     \end{equation}
     #+end_src
     #+end_quote
   - 回帰式のあてはまり具合を評価する代表的な指標

** 決定係数 (\(R^2\)値)
   - *決定係数* (R-squared):
     #+begin_quote
     #+begin_src latex
     \begin{equation}
       R^2
       =
       1-\frac{\sum_{i=1}^n\hat{\epsilon}_i^2}{\sum_{i=1}^n(y_i-\bar{y})^2}
     \end{equation}
     #+end_src
     #+end_quote
   - *自由度調整済み決定係数* (adjusted R-squared):
     #+begin_quote
     #+begin_src latex
     \begin{equation}
       \bar{R}^2
       =
       1-\frac{\frac{1}{n{-}p{-}1}\sum_{i=1}^n\hat{\epsilon}_i^2}
       {\frac{1}{n{-}1}\sum_{i=1}^n(y_i-\bar{y})^2}
     \end{equation}
     #+end_src
     不偏分散で補正している
     #+end_quote

** COMMENT 演習: 決定係数
   :PROPERTIES:
   :reveal_background: #EEEEFF
   :END:
   - [[./code/04-rsq.r][04-rsq.r]] を確認してみよう

** COMMENT 演習
   :PROPERTIES:
   :reveal_background: #EEEEFF
   :END:
   #+ATTR_HTML: :align left
   - 以下のデータで回帰分析を行ってみよう
     - datasets::airquality
     - datasets::LifeCycleSavings

** 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 決定係数を用いてモデルの比較を行ってみなさい
     - 東京都の8月の気候データ
       #+begin_quote
       temp ~ solar

       temp ~ solar + press

       temp ~ solar + press + cloud
       #+end_quote
     - 広告費と売上データ
       #+begin_quote
       sales ~ TV
       
       sales ~ radio

       sales ~ TV + radio
       #+end_quote
     #+begin_src R :eval no :exports none :tangle yes
       ### 練習4
       ### 決定係数によるモデルの比較

       ### 東京都の気候データ
       TW.subset <- subset(TW.data, # 8月のデータの抽出
                           subset= months(as.Date(date),
                                          abbreviate=TRUE)==" 8")
       TW.model1 <- temp ~ solar
       TW.model2 <- temp ~ solar + press
       TW.model3 <- temp ~ solar + press + cloud
       TW.est1 <- lm(TW.model1, data=TW.subset, y=TRUE)
       TW.est2 <- lm(TW.model2, data=TW.subset, y=TRUE)
       TW.est3 <- lm(TW.model3, data=TW.subset, y=TRUE)
       summary(TW.est1)$adj.r.squared # 自由度調整済み決定係数
       summary(TW.est2)$adj.r.squared # (model1より上昇)
       summary(TW.est3)$adj.r.squared # (model2より上昇)
       ## 予測値と実測値の比較
       with(TW.est1,
            plot(y,fitted.values,col="orange",pch=17, # 三角
                 xlab="temperature",
                 ylab="fitted values",ylim=range(y)))   
       abline(0,1,col="red",lwd=2)
       with(TW.est2,
            points(y,fitted.values,col="green",pch=15)) # 四角
       with(TW.est3,
            points(y,fitted.values,col="blue",pch=16))  # 丸
       legend("bottomright",inset=.05, # 凡例の作成
              col=c("orange","green","blue"), pch=c(17,15,16), 
              legend=c("model1","model2","model3"))

       ### 広告費と売上データ
       Adv.model1 <- sales ~ TV
       Adv.model2 <- sales ~ radio
       Adv.model3 <- sales ~ TV + radio
       Adv.est1 <- lm(Adv.model1, data=Adv.data, y=TRUE)
       Adv.est2 <- lm(Adv.model2, data=Adv.data, y=TRUE)
       Adv.est3 <- lm(Adv.model3, data=Adv.data, y=TRUE)
       summary(Adv.est1)$adj.r.squared # 自由度調整済み決定係数
       summary(Adv.est2)$adj.r.squared # (model1より減少)
       summary(Adv.est3)$adj.r.squared # (model1より上昇)
       ## 予測値と実測値の比較
       with(Adv.est1,
            plot(y,fitted.values,col="orange",pch=17, # 三角
                 xlab="sales",
                 ylab="fitted values",ylim=range(y)))   
       abline(0,1,col="red",lwd=2)
       with(Adv.est2,
            points(y,fitted.values,col="green",pch=15)) # 四角
       with(Adv.est3,
            points(y,fitted.values,col="blue",pch=16))  # 丸
       legend("bottomright",inset=.05, # 凡例の作成
              col=c("orange","green","blue"), pch=c(17,15,16), 
              legend=c("model1","model2","model3"))
     #+end_src

* 補足
  - 人工データを作成して
    回帰分析の性質を調べるコード(Rscript)
    ついては以下を参照して下さい
    - 講義ノート
      - 多変量解析 第1章 単回帰分析
      - 多変量解析 第2章 回帰分析

	
* COMMENT ローカル変数
# Local Variables:
# org-latex-listings: minted
# End:
